
#Cell Society Design Document
##Team 04
##Team members: Talha Koç, Maddie Briere, Stone Mathers
###Completed: February 15th, 2017
___

##High-Level Design Goals
The largest design goal for our team was hierarchical design. The nature of the challenge clearly indicates a necessity for inheritance on both and high and low-level. Hence, we focused heavily on creating logical inheritance patterns and consolidating common code in abstract superclasses. Following this trend, we have an abstract superclass, CellSociety, that defines many of the general capabilities for ALL Cell Societies, including random generation of Cells, storage of common variables (simulation name, dimensions, etc.). This superclass has a subclass for each simulation, which dictates the simulation-specific settings. Similarly the superclass Cell, which is abstract and defines only basic Cell functions (like copy, equals and compareTo), has a subclass for each Cell type. The specific cell then fills in the Cell-specific nature through the update method. Hence, all of the Cells can be updated at the same time without having to treat any Cells specially -- this allows for easy extension of the design. The same types of inheritance patterns can be seen littered throughout the project. We knew that we would have to make a lot of changes to our design during the last sprint, in order to accommodate new features, and tried our best to make the work required as minimal as possible. Not only would it save us time, but it would also confirm that our design was well-planned and constructed. 
The next largest goal was separation, yet cohesion, of different components. We strove to make sure that no part of the code was particularly dependent upon the form of implementation used by another part of the project. Hence, the front-end is able to update the grid solely by storing initial information about the simulation and receiving a 2D array of Colors from the back-end with each update. Were the entire implementation to change, the front-end would pay no mind -- it only cares that it gets the 2D array of Colors with each step. Likewise, although we wanted each part to be as separate as possible, we also wanted the parts to go logically together. Hence, we did not have Cells update in radically different ways. Each returns an updated List of Cells when it is done. The types of returns and parameter passes remain consistent across similar classes.
Every time we added a new feature, especially in the last sprint, we tried to make sure that the addition was actually improving the design and stretching its flexibility, not adding irrelevant functionality. Hence, as we tried to get different shapes to display for the Cells, and to change the types of neighbors functions, we created new ways to make these changes so that similar future changes would be easier to accomplish. There are several portions added to our code that don’t have any functionality (currently), but demonstrate that our code could be extended to other applications if need be. For instance, the PatchMap is added to show that our design could facilitate the logical creation and hand-off of different patch types in order to change the behavior of a simulation.
Implementation and organization is meant to be intuitive in our design. We strove to make it so that adding new features is a logical process, not a search for dependent functions. This likely was not as successful as we hoped, but was definitely an improvement from our Breakout Games. 
Another goal of ours was intuitive use (with regards to the GUI). We strove to give the user as many options as possible, giving them a drop-down menu to choose simulations, a button from which to choose XML files, images of shapes to click on, types of boundaries to choose, labeled sliders, and start/stop/pause options. The goal was to provide as much functionality as possible, so that the user could take the simulation where they wanted to, and even extend the product for their own purposes.

##Adding new features
**Adding a new simulation**
	Adding a new simulation requires that you add a new CellSociety (subclass of the abstract class CellSociety) that dictates specifically how that society will function. This includes defining the empty color returned by the society (fills in non-cell patches). This also requires choosing the patch type to fill the board. For most of the simulations, the patch type is Empty, because the patches have no functionality. The patches only need to be defined if the simulation specifically requires that locations have a certain type of memory, such as SlimeSociety, which requires that each location hold a certain concentration of cAMP. Hence, the Slime Simulation also defines a specific type of patch, SlimePatch, and implements functionality around this changing concentration. Luckily, none of the framework for these updates actually has to be added. The CellSociety has a step function already defined that updates the cells and patches by calling upon abstract methods which must be defined by the subclasses. Hence, the second you create a subclass of CellSociety, you are forced to implement all of the necessary methods. This includes parseRules, which takes in a RawData object and parses the society-specific variables, storing them for application through the applySettings method.
	Once a new society has been created, you must give the UI a way to actually work with it. GUIMain is the main class responsible for displaying the GUI components, like GridView, and  deciding what to do with user input. It contains a reference to the CellSociety (_model) which it uses to move information between the backend and frontend. 
The only method that GUIMain uses from CellSociety is the step method. GUIMain calls this method in its own step method, retrieves a Tuple with a 2D-array of colors and a dimension object, and passes both of these variables to the GridController to update the color of the cells on display and/or resize the grid if necessary. 
When the user decides to change the simulation, modify the grid size, change the cell shapes, etc., GUIMain must create a new instance of CellSociety and reinitialize some of the GUI components like GridView. GUIMain has no access to anything in the backend except for the step function. So, the backend developers don’t need to worry about GUIMain modifying CellSociety in an unintended way.
	In addition, to implementing use of the society from the front-end, you must also allow for use of the society through files. This requires first adding a new subclass of SimulationType. This class must have a List of Strings that will be the file tags for each simulation setting, a List of Strings holding the default values for each of these tags, and a List of Strings representing the initial Cells by probability (“0.XX CellName”). The constructor must initialize the SimulationType’s *settingTypes*, *settingDefaults*, and *defaultCellData* with these Lists. It then must initialize SimulationType’s *dataTypes* with the *combineDataTypes* method, *dataDefaults* with the *combineDefaultData* method, *myDataValues* with *createDataMap*, *cellData* with *createCellList*, and *boardData* with *createBoardData*. You must then create a getter method for each setting and implement *getIntegerData*, *getDoubleData*, and *getSimulationName* (which requires adding an enum for your simulation in the SimulationName class.) You must then go into the XMLParser class and add a String to represent your simulation to *POSSIBLE_SIM_STRINGS* and an instance of your new SimulationType subclass to *POSSIBLE_SIM_TYPES*. Additionally, if you wish to allow the user to determine a new feature that applies to all simulations, you can go into SimulationType and add a new String tag for this feature in *UNIVERSAL_DATA_TYPES* and a default value to *DEFAULT_UNIVERSAL_DATA*, along with a getter method for the feature.
	You also have to define the new Cells that inhabit your simulation. To define a new cell, you add its name to the CellName enum list and create a subclass of Cell of the appropriate name. You then must implement the update method, which takes in a CellData object and returns the updated Cells in a List. These updates will be specific to the simulation and will likely require the storage  and maintenance of variables unique to the simulation. Note that you may have to create more than one Cell type if the Cells in your simulation have unique enough functions. 
	Once you have defined the Cells for your simulation, you must also define Patches for your simulation (if you will not be relying on the EmptyPatch). This also requires the creation of a subclass of the abstract class Patch. This inheritance will require that you implement the update class -- this is the method in which you much make specific changes to the state of the Patch, dependent upon the Cell it is holding and other variables (which you may choose and define).

**Adding a new button**
Adding new buttons depends on what kind of button you are adding. For the buttons on the bottom of the screen (pause, play, reset), use the makePlainButton method to get the default style of the button. For the shape buttons, you need to manually define a shape using the polygon tool and add a MouseEvent handler to detect mouse clicks.
**Adding a new Cell shape**
	Adding a new cell shape is relatively simple compared to some of the other features. All you have to do is add the cell shape to the CellShape enum list and then implement a neighbors function unique to the CellShape. To do this, one must add a new neighbors class of the appropriate name (e.g., TriangleNeighbors for a triangle) to the neighbors package, and extend the Neighbors class. 
This part is most of the work, as you must work through what types of neighbors should be allowed, how the shapes will be ordered, etc. This does require some communication between the front and back end (it would be a huge problem if the back-end implemented the cell grid one way, and the front-end drew it another -- this would produce highly unexpected behavior). 
After the correct neighbors function has been created, the means to produce an instance of this class must be added to NeighborsChooser (this will essentially just be another if statement). The CellSociety will be able to use this to choose a type of Neighbors object to make decisions with. 
In addition to these back-end choices, the front-end must add a button to allow for the user to actually select this Cell shape (as well as add in this clicking functionality to the button set-up), and the file-reading end must also make such choices available (see file creation section). The front-end must also add in implementation for what happens when this cell shape is actually chosen. 
GUIMain uses the GridController object to instantiate a new grid with the specified shape. GridView is the abstract class used to create grid views for specific shapes. The underlying data structure for all GridView subclasses is a 2D-array of Shape objects. The SquareGridView was implemented using a 2D-array of Rectangle objects and the HexagonGridView and TriangleGridView were implemented using a 2D-array of Polygon objects. Furthermore, GridView subclasses must implement the updateGridView method which updates the colors of the shapes in the 2D-array. 
The GridController takes the responsibility for maintaining the correct GridView that the user sees. For example, when the user changes the size of the grid, GridController instantiates a new GridView with the given dimensions. 

**Adding a new border type**
Our simulation currently supports border types for finite and toroidal. We tried to implement the infinite border type, but we found that it is difficult to implement because of the variance in gridviews that hold different cell shapes. Currently, the infinite border type is supported for SquareGridView only. However, slight modifications to the GridResizer class can accomodate for a better infinite border type.

**Adding Controls to change simulation parameters**
Although we didn’t have the time to implement this feature into our GUI, the backend is setup to easily support this feature. The data structures that we pass from the frontend to the backend already include parameters like the ratios cells and the threshold variable. Thus, this feature can be implemented in the same way that the grid size slider was implemented.

**Creating a new file**
	Creating a new XML file has only one requirement, in that you must have the attribute “simulation” at the head of the file and set it equal to one of the valid simulation names in *POSSIBLE_SIM_STRINGS* (found in XMLParser). Beyond this, you can implement as many of the available tags as you want, which are found in XMLParser’s *UNIVERSAL_DATA_TYPES* and your particular simulation’s List of setting types. Any tag that is not implemented will be filled with a default value, and any extra tags will be ignored. Any duplicated tags, improperly formatted data, invalid data (incorrect simulation name, letters for numerical data, etc.) or other errors will be caught at runtime and you will be provided a message indicating the problem. 


##Design choices
	The back-end required a wide variety of design choices. The biggest set of design choices involved inheritance. It was decided that a parallel type of structure would be set up in various parts of the back-end, with Cell having subclasses of unique Cell types, CellSociety having subclasses unique to each Society type, SimulationType having subclasses unique to each Simulation Type and Patch having subclasses unique to each different Patch type. 
	In some ways, these were good design choices. The inheritance structure makes it really clear what must be implemented when you add a new part (as the abstract class requires the a concrete subclass implement its abstract methods). It also sets up a logical connection between different components, off of which to make decisions.
	However, we didn’t realize until too late that this structure also had some very serious negatives. One of the biggest was the challenge of coupling. On one hand, we didn’t want to have any component unnecessarily dependent upon other classes, so we didn’t put all of the components for one simulation in a single class. However, by separating all of these parts, it made it very challenging to set boundaries on what is actually “allowed.” For instance, it is still very much so possible to add a SlimeCell to a FireSociety simulation in our design, even though nothing will really happen with it (it would have no SlimePatches to make update decisions off of). In giving our classes freedom, we gave our design too much flexibility. If we were to go back and redo this design, we would likely put in a paradigm for checking the types of Patches and Cells being put into a Society. This would keep strange errors from occurring and would also save us from all of the terrible instanceof-checks and casting set-ups.
	Another design decision that shifted the paradigm of our design was the introduction of the CellData class. At one point in early development, we just passing around an entire CellSociety to Cells when they were updating. We quickly realized, however, that this type of access is not necessary, nor desirable. Were the Cell to make drastic changes to the CellSociety, the program could crash. Hence, we introduced the CellData class to limit the amount of information and access given during updates. It has many getters that work with copies (as indicated in their names), and other functions that do return valid Cells or Patches (not copies) but only in certain situations (e.g., if they are neighbors). The only negative about this design is that it is not all that closed -- any time a new type of information is required by an updating component, this method has to be added to the CellData class. A type of hierarchy may have been the way to go with this design (if we could properly layout the system of relationships).
	Another huge design choice came in the form of enums. Many of our classifications center on enums (CellShape, CellName, SimulationName, PatchName, etc.). We used these classifiers in order to avoid having to introduce new comparison methods, and to make clear to the user what types of options are available. However, these enums also require that the user update each list with modification. For instance, it is not possible to add a new Cell and then use it without first adding an enum to represent it in CellName. It can be challenging to keep track of all of the places where modifications must be made.
	We also actively decided to create a central structure for simulation information. It became rapidly apparent that  the parallels between file-end and user-end input were too great to not consolidate. For instance, although a file can define cell locations while the user defines cell ratios, both avenues can give values for constants, choose a simulation type, define the desired color, etc. We put all of this information in the BoardData class, and both SimulationType (file-end) and SimulationData (user-end) work with this data structure in communicating with CellSociety. 
	In file reading, we decided to abstract the data holding and interpreting class, SimulationType, so that it could easily be extended when creating a new simulation. It was also done in order to establish the data, such as title, author, and dimension, that all simulations must have. The subclasses could then handle all simulation-specific settings and methods. This also allows for dynamic casting at runtime of the SimulationType that XMLParser returns using reflection. One trade off is an unattractive boilerplate constructor, for SimulationType has certain values that must be initialized, but only after the subclass is known, as each subclass’ tags and default values need to be combined with SimulationType’s.
	We also decided to only handle XML in one class, the XMLParser. As a result, no other class needs to go through the setup required to read in XML, know the specific formatting rules, or deal with the user file directly in any way. 
	Lastly, the handling of raw cell data was extracted to two classes, CellDataDecoder and CellDataGenerator. The functionality of CellDataDecoder, which uses a given String to determine how to translate the given cell data into location-style cell data, was originally in XMLParser. This was extracted for two reasons: to hide implementation (an unattractive string of else-if statements) and to avoid code duplication. Originally, only XMLParser needed to be able to alter the data’s raw file format. However, with the implementation of default values, and wanting to avoid hardcoding cell positions, especially when the grid size is unknown, SimulationType had to be able to translate percentage-based data. CellDataGenerator was also created to hide implementation, so that XMLParser did not have to deal with the algorithms necessary to calculate and write the new data.

##Assumptions and Decisions
	As mentioned in the Design section, because we wanted to create an intuitive hierarchical structure, with parallel types of inheritance across the program, our design gives users almost too much flexibility. Hence, we made a huge assumption that the user would NOT incorrectly place Cells and Patches, or try to mix and match different components. We tried to document the expected use, but even with documentation, that part of the set-up is not entirely intuitive.
	There are also many places in the back-end where nulls are thrown around (e.g., when a target location is not available). It is assumed that user working with these methods will be aware that null is a possible output -- this is a HUGE assumption that was only slightly reasonable because of the small size of our team. This assumption was made to avoid the complexities of conveying the lack of a cell/patch without null. This would have required the addition of a new data structure to hold empty Cells -- we had already removed that class in favor of working with empty Patches instead, so adding back an old structure would have made our code messy and buggy. On any other project, and moving forward, we will endeavor to avoid assumptions about the knowledge and intentions of future users.
	We also made a lot of simplifying assumptions about the simulations (and their rules). For instance, the Wa-Tor world simulation that we implemented actually updates all of the shark before the fish. This is NOT to say that the decisions are not simultaneous (which is a requirement if the CA design) -- rather that certain cells receive priority in choosing new states. That is, the shark can eat a fish and set its isEaten variable to true, so that when that fish goes to update, it will die off. This simplified the logic behind conflict resolution (before, a fish could move before a Shark had marked it as eaten), and allowed us to avoid having to do a second-check on the resulting List of updated Cells (i.e., to check if two HouseCells had moved to the same location).
	Similarly, in SlimeSociety and SugarSociety, we made the rules much more simplistic in order to improve the ease of programming. The goal of adding new societies was not to show that we could come of with complex implementations -- it was to show that our design can handle new simulation types (e.g., with the addition of patches). Hence, for instance, in SlimeSociety, the “random walk” described by the online tutorial is not implemented in its entirety. The description dictates that the Cell move in a certain direction and have an angle of freedom (through which it could change its direction). We simply coded in a completely random walk. In SugarSociety, we did not end up adding in the patch grid of different concentrations. We demonstrated that this would be possible by designing PatchMap, but did not want to spend time following through with the implementation. We focused instead of stretching our program and giving it a breadth of functionalities. Other similar types of simplifications can be seen throughout these two simulations.
	Another assumption we make is that each Patch will only ever hold one Cell -- our design would not be able to handle a simulation in which Cells could occupy the same Patch at once. This decision was made in order to avoid possible conflicts (as all of the simulations we produced do NOT allow Cells to overlap). This decision was made to simplify the back-end coding and to keep errors from occurring.
	In dealing with files, it was assumed that the user would be able to access the valid simulation names and tag names, otherwise XMLParser will not be able to recognize the file as valid or collect the data that it holds. Currently, this means that the user has access to SimulationType and its subclasses and can see the **final** Lists containing all valid attributes and tags. In order to not require this level of access, we would likely move this information to *properties* files in further refactoring. We also decided to simply display to the user an error-specific message when their file is incorrectly formatted, thus forcing them to fix the problem. This saved us the time required to devise algorithms that attempt to fix any issues that arise, some of which can be quite complicated. At the same time, this provides the user with very little flexibility, requires that they know the file formatting well, and forces them to be very careful with details such as spelling and spacing.
